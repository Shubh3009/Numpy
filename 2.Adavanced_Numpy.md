# NumPy Advanced Operations Notes

## 1. NUMPY VS PYTHON LISTS

### **Speed Comparison**
```python
import time
import numpy as np

# Python lists - slow element-wise addition
a = [i for i in range(10000000)]
b = [i for i in range(10000000, 20000000)]
c = []

start = time.time()
for i in range(len(a)):
    c.append(a[i] + b[i])  # Should be c.append(), not c=[...]
print("Python list time:", time.time() - start)
# Output: ~0.85 seconds (slow!)

# NumPy arrays - vectorized operation
e = np.arange(10000000)
f = np.arange(10000000, 20000000)

start = time.time()
g = e + f  # Single vectorized operation
print("NumPy time:", time.time() - start)
# Output: ~0.022 seconds

# NumPy is ~37x faster!
```

### **Memory Efficiency**
```python
import sys

# Python list - stores each element as separate object
a = [i for i in range(10000000)]
print("Python list size:", sys.getsizeof(a))  # ~835 MB

# NumPy array - stores data in contiguous memory
e = np.arange(10000000, dtype=np.int32)
print("NumPy array size:", sys.getsizeof(e))  # ~40 MB

# NumPy uses ~95% less memory!
```

---

## 2. ADVANCED INDEXING

### **Fancy Indexing (Indexing with Arrays)**
```python
a = np.arange(24).reshape(6,4)
print(a)
"""
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]
 [16 17 18 19]
 [20 21 22 23]]
"""

# Select specific rows
print(a[[0, 2, 3]])  # Rows 0, 2, and 3
"""
[[ 0  1  2  3]
 [ 8  9 10 11]
 [12 13 14 15]]
"""

print(a[[0, 2, 3, 5]])  # Rows 0, 2, 3, and 5

# Select specific columns
print(a[:, [0, 2, 3]])  # All rows, columns 0, 2, and 3
"""
[[ 0  2  3]
 [ 4  6  7]
 [ 8 10 11]
 [12 14 15]
 [16 18 19]
 [20 22 23]]
"""
```

### **Boolean Indexing**
```python
a = np.random.randint(1, 100, 24).reshape(6,4)
print(a)
"""
[[98 36 39 94]
 [29 80 80 20]
 [94 85 37 59]
 [62 16 17 82]
 [44 28 58 59]
 [24 51 13 48]]
"""

# Find all numbers greater than 50
print(a[a > 50])
# Output: [98 94 80 80 94 85 59 62 82 58 59 51]

# Find all even numbers
print(a[a % 2 == 0])
# Output: [98 36 94 80 80 20 94 62 16 82 44 28 58 24 48]

# Combined conditions (use &, |, ~ for AND, OR, NOT)
print(a[(a > 50) & (a % 2 == 0)])  # Even numbers > 50
# Output: [98 94 80 80 94 62 82 58]

# Numbers NOT divisible by 7
print(a[a % 7 != 0])
# Numbers not equal to multiples of 7
```

---

## 3. BROADCASTING

### **What is Broadcasting?**
Broadcasting allows NumPy to perform operations on arrays of different shapes by "stretching" the smaller array to match the larger one's shape.

### **Basic Examples**
```python
# Same shape - works directly
a = np.arange(6).reshape(2,3)
b = np.arange(6,12).reshape(2,3)
print(a + b)
"""
[[ 6  8 10]
 [12 14 16]]
"""

# Broadcasting: (2,3) + (1,3) → (2,3)
a = np.arange(6).reshape(2,3)
b = np.arange(3).reshape(1,3)  # Row vector
print(a + b)
"""
[[0 2 4]
 [3 5 7]]
# b is broadcast to [[0 1 2], [0 1 2]]
"""
```

### **Broadcasting Rules**
1. **Add dimensions**: If arrays have different dimensions, add size-1 dimensions to the front
2. **Stretch size-1 dimensions**: Size-1 dimensions are stretched to match the other array

```python
# Example 1: (4,3) + (3,) → (4,3)
a = np.arange(12).reshape(4,3)
b = np.arange(3)  # Shape (3,) becomes (1,3) then (4,3)
print(a + b)
"""
[[ 0  2  4]
 [ 3  5  7]
 [ 6  8 10]
 [ 9 11 13]]
"""

# Example 2: (3,4) + (3,) → ERROR!
a = np.arange(12).reshape(3,4)
b = np.arange(3)
# print(a + b)  # ValueError: shapes (3,4) and (3,) not aligned

# Example 3: (4,1) + (3,) → (4,3)
a = np.arange(4).reshape(4,1)  # Column vector
b = np.arange(3)  # Row vector (after broadcasting)
print(a + b)
"""
[[0 1 2]
 [1 2 3]
 [2 3 4]
 [3 4 5]]
"""

# Example 4: Scalar broadcasting
a = np.array([1])  # Shape (1,)
b = np.arange(4).reshape(2,2)
print(a + b)  # a broadcast to [[1 1], [1 1]]
"""
[[1 2]
 [3 4]]
"""
```

---

## 4. WORKING WITH MATHEMATICAL FORMULAS

### **Mathematical Functions**
```python
# Trigonometric functions
a = np.arange(10)
print(np.sin(a))
# [0., 0.8415, 0.9093, 0.1411, -0.7568, -0.9589, -0.2794, 0.657, 0.9894, 0.4121]

# Sigmoid function (logistic function)
def sigmoid(array):
    return 1 / (1 + np.exp(-array))

print(sigmoid(np.arange(10)))
# [0.5, 0.7311, 0.8808, 0.9526, 0.982, 0.9933, 0.9975, 0.9991, 0.9997, 0.9999]

# Mean Squared Error (common in ML)
def mse(actual, predicted):
    return np.mean((actual - predicted) ** 2)

actual = np.random.randint(1, 50, 25)
predicted = np.random.randint(1, 50, 25)
print("MSE:", mse(actual, predicted))
```

---

## 5. HANDLING MISSING VALUES

```python
# Create array with NaN (Not a Number)
a = np.array([1, 2, 3, 4, 5, np.nan, 7])
print(a)  # [ 1.  2.  3.  4.  5. nan  7.]

# Remove NaN values
clean_a = a[~np.isnan(a)]  # ~ is logical NOT
print(clean_a)  # [1. 2. 3. 4. 5. 7.]
```

---

## 6. PLOTTING WITH MATPLOTLIB

```python
import matplotlib.pyplot as plt
import numpy as np

# Linear function: y = x
x = np.linspace(-10, 10, 100)  # 100 points from -10 to 10
y = x
plt.plot(x, y)
plt.title("y = x")
plt.show()

# Quadratic function: y = x²
x = np.linspace(-10, 10, 100)
y = x**2
plt.plot(x, y)
plt.title("y = x²")
plt.show()

# Sine wave
x = np.linspace(-10, 10, 100)
y = np.sin(x)
plt.plot(x, y)
plt.title("y = sin(x)")
plt.show()

# Handle warnings with np.log
x = np.linspace(0.1, 10, 100)  # Start from 0.1 to avoid log(0)
y = x * np.log(x)
plt.plot(x, y)
plt.title("y = x·log(x)")
plt.show()

# Sigmoid function plot
x = np.linspace(-10, 10, 100)
y = 1 / (1 + np.exp(-x))
plt.plot(x, y)
plt.title("Sigmoid Function")
plt.show()
```

---

## KEY TAKEAWAYS

1. **Performance**: NumPy is ~37x faster and uses ~95% less memory than Python lists
2. **Advanced Indexing**:
   - Fancy indexing: Select multiple elements using arrays of indices
   - Boolean indexing: Filter using conditions
3. **Broadcasting**: NumPy automatically handles operations between arrays of different shapes
4. **Mathematical Operations**: NumPy provides vectorized implementations of complex formulas
5. **Missing Values**: Use `np.nan` and `~np.isnan()` to handle missing data
6. **Plotting**: NumPy arrays integrate seamlessly with Matplotlib for data visualization

## COMMON ERRORS AND SOLUTIONS

1. **Broadcasting Error**: "operands could not be broadcast together"
   - Check that size-1 dimensions can be stretched to match
   - Remember: dimensions align from right to left

2. **NaN Handling**: Use `~np.isnan()` to filter out NaN values

3. **Log Domain Error**: `np.log()` requires positive inputs
   - Adjust domain or use `np.log1p()` for log(1+x)
